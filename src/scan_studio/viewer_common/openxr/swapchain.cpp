#ifdef HAVE_OPENXR

#include "scan_studio/viewer_common/openxr/swapchain.hpp"

#include <loguru.hpp>

namespace scan_studio {

OpenXRSwapchain::OpenXRSwapchain() {}

OpenXRSwapchain::OpenXRSwapchain(OpenXRSwapchain&& other)
    : swapchain(std::move(other.swapchain)),
      depthSwapchain(std::move(other.depthSwapchain)),
      width(other.width),
      height(other.height),
      swapchainImages(std::move(other.swapchainImages)),
      depthSwapchainImages(std::move(other.depthSwapchainImages)),
      swapchainImageViews(std::move(other.swapchainImageViews)),
      depthSwapchainImageViews(std::move(other.depthSwapchainImageViews)),
      swapchainFramebuffers(std::move(other.swapchainFramebuffers)) {
  other.swapchain = XR_NULL_HANDLE;
  other.depthSwapchain = XR_NULL_HANDLE;
}

OpenXRSwapchain& OpenXRSwapchain::operator=(OpenXRSwapchain&& other) {
  Destroy();
  
  swapchain = std::move(other.swapchain);
  depthSwapchain = std::move(other.depthSwapchain);
  width = other.width;
  height = other.height;
  swapchainImages = std::move(other.swapchainImages);
  depthSwapchainImages = std::move(other.depthSwapchainImages);
  swapchainImageViews = std::move(other.swapchainImageViews);
  depthSwapchainImageViews = std::move(other.depthSwapchainImageViews);
  swapchainFramebuffers = std::move(other.swapchainFramebuffers);
  
  other.swapchain = XR_NULL_HANDLE;
  other.depthSwapchain = XR_NULL_HANDLE;
  return *this;
}

OpenXRSwapchain::~OpenXRSwapchain() {
  Destroy();
}

bool OpenXRSwapchain::Initialize(
    VkFormat colorFormat,
    VkSampleCountFlagBits msaaSamples,
    VkFormat depthFormat,
    bool singleDepthImageOnly,
    const XrViewConfigurationView& view,
    XrSession session,
    VkRenderPass renderPass,
    const VulkanDevice& device) {
  width = view.recommendedImageRectWidth;
  height = view.recommendedImageRectHeight;
  
  LOG(1) << "OpenXRSwapchain: Using sample count: " << view.recommendedSwapchainSampleCount << " (max: " << view.maxSwapchainSampleCount << ")";
  
  // TODO: I use XR_SWAPCHAIN_USAGE_SAMPLED_BIT because the example codes that I have seen use it as well.
  //       We actually do not sample from our swap chain images ourselves, but perhaps (some of?) the OpenXR runtimes do that?
  
  // Create color swapchain
  XrSwapchainCreateInfo swapchainInfo = {XR_TYPE_SWAPCHAIN_CREATE_INFO};
  swapchainInfo.arraySize = 1;  // not using a texture array
  swapchainInfo.mipCount = 1;  // not using mip maps
  swapchainInfo.faceCount = 1;  // 1 for normal textures, 6 for cube maps
  swapchainInfo.format = colorFormat;
  swapchainInfo.width = width;
  swapchainInfo.height = height;
  swapchainInfo.sampleCount = view.recommendedSwapchainSampleCount;
  swapchainInfo.usageFlags = XR_SWAPCHAIN_USAGE_SAMPLED_BIT | XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT;
  if (!XrCheckResult(xrCreateSwapchain(session, &swapchainInfo, &swapchain))) {
    return false;
  }
  
  // Query the VkImages generated by OpenXR in the swapchain
  u32 imageCount;
  if (!XrCheckResult(xrEnumerateSwapchainImages(swapchain, 0, &imageCount, nullptr))) {
    return false;
  }
  LOG(1) << "OpenXRSwapchain: color imageCount: " << imageCount;
  swapchainImages.resize(imageCount, {XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR});
  if (!XrCheckResult(xrEnumerateSwapchainImages(swapchain, imageCount, &imageCount, reinterpret_cast<XrSwapchainImageBaseHeader*>(swapchainImages.data())))) {
    return false;
  }
  
  // Create an image view for each image in the swap chain.
  swapchainImageViews.resize(imageCount);
  for (usize i = 0; i < swapchainImageViews.size(); ++ i) {
    if (!swapchainImageViews[i].Initialize(VK_IMAGE_ASPECT_COLOR_BIT, swapchainImages[i].image, colorFormat, /*mip_levels*/ 1, /*layer_count*/ 1, device)) {
      LOG(ERROR) << "Failed to create an image view for a swap chain color image.";
      return false;
    }
  }
  
  // If msaa is enabled, create an image holding the msaa samples
  if (msaaSamples != VK_SAMPLE_COUNT_1_BIT) {
    msaaImage.create_info().samples = msaaSamples;
    if (!msaaImage.Initialize(width, height, colorFormat, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, device)) {
      LOG(ERROR) << "Failed to allocate msaa image";
      return false;
    }
    
    if (!msaaImageView.Initialize(VK_IMAGE_ASPECT_COLOR_BIT, msaaImage)) {
      LOG(ERROR) << "Failed to allocate msaa image view";
      return false;
    }
  }
  
  u32 depthImageCount;
  
  if (singleDepthImageOnly) {
    // Create single depth image
    depthImageCount = 1;
    
    singleDepthImage.create_info().samples = msaaSamples;
    if (!singleDepthImage.Initialize(width, height, depthFormat, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, device)) {
      return false;
    }
    
    depthSwapchainImageViews.resize(1);
    if (!depthSwapchainImageViews.front().Initialize(VK_IMAGE_ASPECT_DEPTH_BIT, singleDepthImage)) {
      return false;
    }
  } else {
    // Create depthSwapchain
    swapchainInfo.format = depthFormat;
    swapchainInfo.sampleCount = msaaSamples;
    swapchainInfo.usageFlags = XR_SWAPCHAIN_USAGE_SAMPLED_BIT | XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;
    if (!XrCheckResult(xrCreateSwapchain(session, &swapchainInfo, &depthSwapchain))) {
      return false;
    }
    
    // Query the VkImages generated by OpenXR in the depthSwapchain
    if (!XrCheckResult(xrEnumerateSwapchainImages(depthSwapchain, 0, &depthImageCount, nullptr))) {
      return false;
    }
    LOG(1) << "OpenXRSwapchain: depthImageCount: " << depthImageCount;
    depthSwapchainImages.resize(depthImageCount, {XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR});
    if (!XrCheckResult(xrEnumerateSwapchainImages(depthSwapchain, depthImageCount, &depthImageCount, reinterpret_cast<XrSwapchainImageBaseHeader*>(depthSwapchainImages.data())))) {
      return false;
    }
    
    // Create an image view for each image in the swap chain.
    depthSwapchainImageViews.resize(depthImageCount);
    for (usize i = 0; i < depthSwapchainImageViews.size(); ++ i) {
      if (!depthSwapchainImageViews[i].Initialize(VK_IMAGE_ASPECT_DEPTH_BIT, depthSwapchainImages[i].image, depthFormat, /*mip_levels*/ 1, /*layer_count*/ 1, device)) {
        LOG(ERROR) << "Failed to create an image view for a swap chain depth image.";
        return false;
      }
    }
  }
  
  // Initialize a framebuffer for each combination of color & depth swapchain image
  // TODO: Can we do anything to ensure we use the same indices for color and depth, so we do not need to create all possible combinations?
  //       Does not seem possible, since we do not have control over the swapchain image indices that we get.
  swapchainFramebuffers.resize(imageCount * depthImageCount);
  for (u32 colorImageIndex = 0; colorImageIndex < imageCount; ++ colorImageIndex) {
    for (u32 depthImageIndex = 0; depthImageIndex < depthImageCount; ++ depthImageIndex) {
      VulkanFramebuffer& framebuffer = GetSwapChainFramebuffer(colorImageIndex, depthImageIndex);
      
      if (msaaSamples == VK_SAMPLE_COUNT_1_BIT) {
        framebuffer.AddAttachment(swapchainImageViews[colorImageIndex]);
        framebuffer.AddAttachment(depthSwapchainImageViews[depthImageIndex]);
      } else {
        framebuffer.AddAttachment(msaaImageView);
        framebuffer.AddAttachment(depthSwapchainImageViews[depthImageIndex]);
        framebuffer.AddAttachment(swapchainImageViews[colorImageIndex]);
      }
      
      if (!framebuffer.Initialize(width, height, /*layers*/ 1, device, renderPass)) {
        LOG(ERROR) << "Failed to create a framebuffer.";
        return false;
      }
    }
  }
  
  return true;
}

void OpenXRSwapchain::Destroy() {
  if (swapchain != XR_NULL_HANDLE) {
    xrDestroySwapchain(swapchain);
    swapchain = XR_NULL_HANDLE;
  }
  if (depthSwapchain != XR_NULL_HANDLE) {
    xrDestroySwapchain(depthSwapchain);
    depthSwapchain = XR_NULL_HANDLE;
  }
}

}

#endif
