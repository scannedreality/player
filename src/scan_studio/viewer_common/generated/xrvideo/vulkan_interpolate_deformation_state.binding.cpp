// This file was autogenerated by shaderbind. Do not modify.

#include "vulkan_interpolate_deformation_state.binding.hpp"

#include <libvis/vulkan/device.h>
#include <libvis/vulkan/shader.h>

#include "vulkan_interpolate_deformation_state.comp.h"

using namespace vis;

namespace vulkan_interpolate_deformation_state {

bool CreateDescriptorSet0Layout(VulkanDescriptorSetLayout* layout, const VulkanDevice& device, const DescriptorSet0Config* config) {
  layout->AddBinding(0, (config && config->State1Dynamic) ? VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC : VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);
  layout->AddBinding(1, (config && config->State2Dynamic) ? VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC : VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);
  layout->AddBinding(2, (config && config->OutputDynamic) ? VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC : VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);
  
  return layout->Initialize(device);
}

void DescriptorSet0::Update(
      const VkDescriptorBufferInfo* State1,
      const VkDescriptorBufferInfo* State2,
      const VkDescriptorBufferInfo* Output) {
  VkWriteDescriptorSet writeDescriptorSet[3];
  writeDescriptorSet[0] = VkWriteDescriptorSet{};
  writeDescriptorSet[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  writeDescriptorSet[0].descriptorType = descriptor_types_[0];
  writeDescriptorSet[0].descriptorCount = 1;
  writeDescriptorSet[0].dstSet = descriptor_set_;
  writeDescriptorSet[0].dstBinding = 0;
  writeDescriptorSet[0].pBufferInfo = State1;
  writeDescriptorSet[1] = VkWriteDescriptorSet{};
  writeDescriptorSet[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  writeDescriptorSet[1].descriptorType = descriptor_types_[1];
  writeDescriptorSet[1].descriptorCount = 1;
  writeDescriptorSet[1].dstSet = descriptor_set_;
  writeDescriptorSet[1].dstBinding = 1;
  writeDescriptorSet[1].pBufferInfo = State2;
  writeDescriptorSet[2] = VkWriteDescriptorSet{};
  writeDescriptorSet[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  writeDescriptorSet[2].descriptorType = descriptor_types_[2];
  writeDescriptorSet[2].descriptorCount = 1;
  writeDescriptorSet[2].dstSet = descriptor_set_;
  writeDescriptorSet[2].dstBinding = 2;
  writeDescriptorSet[2].pBufferInfo = Output;
  logical_device_->Api().vkUpdateDescriptorSets(*logical_device_, 3, writeDescriptorSet, 0, nullptr);
}

void DescriptorSet0::UpdateState1(
      const VkDescriptorBufferInfo* State1) {
  VkWriteDescriptorSet writeDescriptorSet[1];
  writeDescriptorSet[0] = VkWriteDescriptorSet{};
  writeDescriptorSet[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  writeDescriptorSet[0].descriptorType = descriptor_types_[0];
  writeDescriptorSet[0].descriptorCount = 1;
  writeDescriptorSet[0].dstSet = descriptor_set_;
  writeDescriptorSet[0].dstBinding = 0;
  writeDescriptorSet[0].pBufferInfo = State1;
  logical_device_->Api().vkUpdateDescriptorSets(*logical_device_, 1, writeDescriptorSet, 0, nullptr);
}

void DescriptorSet0::UpdateState2(
      const VkDescriptorBufferInfo* State2) {
  VkWriteDescriptorSet writeDescriptorSet[1];
  writeDescriptorSet[0] = VkWriteDescriptorSet{};
  writeDescriptorSet[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  writeDescriptorSet[0].descriptorType = descriptor_types_[1];
  writeDescriptorSet[0].descriptorCount = 1;
  writeDescriptorSet[0].dstSet = descriptor_set_;
  writeDescriptorSet[0].dstBinding = 1;
  writeDescriptorSet[0].pBufferInfo = State2;
  logical_device_->Api().vkUpdateDescriptorSets(*logical_device_, 1, writeDescriptorSet, 0, nullptr);
}

void DescriptorSet0::UpdateOutput(
      const VkDescriptorBufferInfo* Output) {
  VkWriteDescriptorSet writeDescriptorSet[1];
  writeDescriptorSet[0] = VkWriteDescriptorSet{};
  writeDescriptorSet[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  writeDescriptorSet[0].descriptorType = descriptor_types_[2];
  writeDescriptorSet[0].descriptorCount = 1;
  writeDescriptorSet[0].dstSet = descriptor_set_;
  writeDescriptorSet[0].dstBinding = 2;
  writeDescriptorSet[0].pBufferInfo = Output;
  logical_device_->Api().vkUpdateDescriptorSets(*logical_device_, 1, writeDescriptorSet, 0, nullptr);
}

bool Program::Initialize(u32 workgroupSizeX, const VkPipelineCache& pipelineCache, const VulkanDevice& device, int descriptorSet0Count, const DescriptorSet0Config* descriptorSetConfig0) {
  descriptorPool.AddPoolSize((descriptorSetConfig0 && descriptorSetConfig0->State1Dynamic) ? VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC : VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, descriptorSet0Count * 1);
  descriptorPool.AddPoolSize((descriptorSetConfig0 && descriptorSetConfig0->State2Dynamic) ? VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC : VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, descriptorSet0Count * 1);
  descriptorPool.AddPoolSize((descriptorSetConfig0 && descriptorSetConfig0->OutputDynamic) ? VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC : VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, descriptorSet0Count * 1);
  if (!descriptorPool.Initialize(/*max_sets*/ descriptorSet0Count, device)) { Destroy(); return false; }
  
  if (!CreateDescriptorSet0Layout(&descriptorSetLayouts[0], device, descriptorSetConfig0)) { Destroy(); return false; }
  
  descriptorSets0.resize(descriptorSet0Count);
  for (usize i = 0; i < descriptorSets0.size(); ++ i) {
    if (!descriptorSets0[i].Initialize(descriptorSetLayouts[0], descriptorPool, device)) { Destroy(); return false; }
  }
  
  pipelineLayout.AddDescriptorSetLayout(descriptorSetLayouts[0]);
  pipelineLayout.AddPushConstantRange(VK_SHADER_STAGE_COMPUTE_BIT, /*offset*/ 0, /*size*/ 8);
  if (!pipelineLayout.Initialize(device)) { Destroy(); return false; }
  
  VulkanShader shader;
  workgroupSize[0] = workgroupSizeX;
  shader.SetSpecialization<u32>(0, &workgroupSizeX);
  if (!shader.Initialize(vulkan_interpolate_deformation_state_comp, VK_SHADER_STAGE_COMPUTE_BIT, device, "main")) {
    return false;
  }
  
  if (!pipeline.Initialize(shader, pipelineLayout, pipelineCache, device)) { Destroy(); return false; }
  
  return true;
}

void Program::Destroy() {
  pipeline.Destroy();
  pipelineLayout.Destroy();
  descriptorSets0.clear();
  descriptorSetLayouts[0].Destroy();
  descriptorPool.Destroy();
}

void Program::CmdUpdatePushConstants(VkCommandBuffer cmdBuf, float factor, vis::u32 coefficientCount) {
  uint8_t buffer[8];
  *reinterpret_cast<float*>(buffer + 0) = factor;
  *reinterpret_cast<vis::u32*>(buffer + 4) = coefficientCount;
  pipeline.GetDevice().Api().vkCmdPushConstants(cmdBuf, pipelineLayout, VK_SHADER_STAGE_COMPUTE_BIT, /*offset*/ 0, /*size*/ 8, buffer);
}

void Program::CmdDispatchGroups(VkCommandBuffer cmdBuf, u32 groupCountX, vis::u32 descriptorSet0Index, u32 dynamicOffsetCount, const u32* pDynamicOffsets) {
  if (groupCountX == 0) {
    return;
  }
  
  const auto& api = pipeline.GetDevice().Api();
  
  api.vkCmdBindPipeline(cmdBuf, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline);
  VkDescriptorSet descriptorSetsToBind[1] = {descriptorSets0[descriptorSet0Index].descriptor_set()};
  api.vkCmdBindDescriptorSets(cmdBuf, VK_PIPELINE_BIND_POINT_COMPUTE, pipelineLayout, /*firstSet*/ 0, 1, descriptorSetsToBind, dynamicOffsetCount, pDynamicOffsets);
  
  api.vkCmdDispatch(cmdBuf, groupCountX, 1, 1);
}

void Program::CmdDispatchOn1DDomain(
    VkCommandBuffer cmdBuf,
    u32 domainSize,
    vis::u32 descriptorSet0Index, u32 dynamicOffsetCount, const u32* pDynamicOffsets) {
  if (domainSize > 0) {
    CmdDispatchGroups(cmdBuf, (domainSize - 1) / workgroupSize[0] + 1, descriptorSet0Index, dynamicOffsetCount, pDynamicOffsets);
  }
}

}
