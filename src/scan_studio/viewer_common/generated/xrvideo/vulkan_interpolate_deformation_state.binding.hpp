// This file was autogenerated by shaderbind. Do not modify.
#pragma once

#include <libvis/vulkan/libvis.h>
#include <libvis/vulkan/compute.h>
#include <libvis/vulkan/descriptors.h>
#include <libvis/vulkan/pipeline.h>

namespace vis {
  class VulkanDescriptorSetLayout;
  class VulkanDevice;
}

namespace vulkan_interpolate_deformation_state {

struct DescriptorSet0Config {
  bool State1Dynamic = false;
  bool State2Dynamic = false;
  bool OutputDynamic = false;
};

bool CreateDescriptorSet0Layout(vis::VulkanDescriptorSetLayout* layout, const vis::VulkanDevice& device, const DescriptorSet0Config* config = nullptr);

class DescriptorSet0 : public vis::VulkanDescriptorSet {
 public:
  /// Updates all descriptors in this set with the given values.
  void Update(
      const VkDescriptorBufferInfo* State1,
      const VkDescriptorBufferInfo* State2,
      const VkDescriptorBufferInfo* Output);
  
  /// Updates the descriptor "State1" (binding 0) in this set with the given value.
  void UpdateState1(
      const VkDescriptorBufferInfo* State1);
  
  /// Updates the descriptor "State2" (binding 1) in this set with the given value.
  void UpdateState2(
      const VkDescriptorBufferInfo* State2);
  
  /// Updates the descriptor "Output" (binding 2) in this set with the given value.
  void UpdateOutput(
      const VkDescriptorBufferInfo* Output);
};

class Program {
 public:
  /// Initializes the object. Returns true if successful, false otherwise.
  bool Initialize(vis::u32 workgroupSizeX, const VkPipelineCache& pipelineCache, const vis::VulkanDevice& device, int descriptorSet0Count = 1, const DescriptorSet0Config* descriptorSetConfig0 = nullptr);
  
  void Destroy();
  
  /// Updates the values of the push constants.
  void CmdUpdatePushConstants(VkCommandBuffer cmdBuf, float factor, vis::u32 coefficientCount);
  
  /// Invokes the compute shader in the given command buffer with the given number of workgroups.
  void CmdDispatchGroups(VkCommandBuffer cmdBuf, vis::u32 groupCountX, vis::u32 descriptorSet0Index = 0, vis::u32 dynamicOffsetCount = 0, const vis::u32* pDynamicOffsets = nullptr);
  
  /// Invokes the compute shader in the given command buffer on the given domain size, automatically
  /// computing the required workgroup count to cover (at least) the whole domain.
  void CmdDispatchOn1DDomain(
      VkCommandBuffer cmdBuf,
      vis::u32 domainSize,
      vis::u32 descriptorSet0Index = 0, vis::u32 dynamicOffsetCount = 0, const vis::u32* pDynamicOffsets = nullptr);
  
  inline const vis::VulkanDescriptorPool& GetDescriptorPool() const { return descriptorPool; }
  inline const vis::VulkanDescriptorSetLayout& GetDescriptorSet0Layout() const { return descriptorSetLayouts[0]; }
  inline const DescriptorSet0& GetDescriptorSet0(vis::u32 index = 0) const { return descriptorSets0[index]; }
  inline DescriptorSet0& GetDescriptorSet0(vis::u32 index = 0) { return descriptorSets0[index]; }
  inline const vis::VulkanPipelineLayout& GetPipelineLayout() const { return pipelineLayout; }
  inline const vis::VulkanComputePipeline& GetPipeline() const { return pipeline; }
  
 private:
  vis::u32 workgroupSize[1];
  
  vis::VulkanDescriptorPool descriptorPool;
  vis::VulkanDescriptorSetLayout descriptorSetLayouts[1];
  std::vector<DescriptorSet0> descriptorSets0;
  vis::VulkanPipelineLayout pipelineLayout;
  vis::VulkanComputePipeline pipeline;
};

}
